from typing import Union, List
import torch
from torch.utils.data import Dataset
from dataproc.crystalToVoxel import cellToVoxel
from dataproc.MP_data import dataFromMp


class CrystalVoxelDataset(Dataset):

    def __init__(self,
                 pool: Union[List[str], str] = "**O3",
                 target: str = "band_gap",
                 stability: str = "energy_above_hull",
                 sigma: Union[float, int] = 0.5,
                 grid_size: int = 20,
                 eden: bool = False) -> None:
        """
        Standard pytorch Dataset class for faster and efficient data extraction and processing.

        :param pool: Either a list of elements that will result in search for compounds containing these elements or
        a formula of the form **O3 that searches for all compounds of the form ABO3
        :param target: The property of the material that you are basing the inverse design for
        :param stability: The property of the material that will determine the stability of the material generated by
        the network
        :param sigma: The standard deviation for the density gaussian function
        :param grid_size: The dimensions of the cubic voxel grid
        :param eden: boolean for 'e'lectronic 'den'sity or nuclear potential model
        """
        self.dataset = dataFromMp(pool=pool,
                                  target=target,
                                  stability=stability).crystalInfo  # extract data from the materials project
        self.crystalToVox = cellToVoxel(sigma=sigma,
                                        dimension=grid_size)  # convert the structures to voxel grid
        self.eden = eden

    def __len__(self) -> int:
        return int(self.dataset.shape[0])

    def __getitem__(self,
                    idx: Union[torch.tensor, int]) -> dict:

        if torch.is_tensor(idx):
            idx = idx.tolist()

        name = f'{self.dataset[idx][1]}({self.dataset[idx][0]})'  # making it easier for visualization and analysis
        target = torch.tensor(self.dataset[idx][2],
                              dtype=torch.float32)  # float32 precision should be enough, float64 unnecessary
        stability = torch.tensor(self.dataset[idx][3], dtype=torch.float32)
        structure = self.dataset[idx][4]  # index values corresponding to structured array from dataset

        voxel_np = self.crystalToVox.speciesToVoxel(structure, eden=self.eden)  # ideally should be a transform property
        voxel = torch.tensor(voxel_np, dtype=torch.float32)
        sample = {'voxel': voxel, 'stability': stability, 'property': target, 'name': name}

        return sample
